(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{161:function(e,t,a){"use strict";a.r(t);var n=a(0),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"vue-runtime-vue-esm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-runtime-vue-esm","aria-hidden":"true"}},[e._v("#")]),e._v(" vue.runtime & vue.esm")]),e._v(" "),a("h2",{attrs:{id:"一-esm是vue-的“运行时”和“编译器”的集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-esm是vue-的“运行时”和“编译器”的集合","aria-hidden":"true"}},[e._v("#")]),e._v(" 一. esm是vue 的“运行时”和“编译器”的集合")]),e._v(" "),a("h3",{attrs:{id:"运行时"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行时","aria-hidden":"true"}},[e._v("#")]),e._v(" 运行时")]),e._v(" "),a("p",[e._v("运行时是用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。")]),e._v(" "),a("h3",{attrs:{id:"编译器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译器","aria-hidden":"true"}},[e._v("#")]),e._v(" 编译器")]),e._v(" "),a("p",[e._v("用来将模板字符串编译成为 JavaScript 渲染函数的代码。")]),e._v(" "),a("p",[e._v("在客户端编译模板包含以下情况：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("el属性指定模版挂载的DOM，和该DOM包含的html，也就是说，既没有指定template，又没有render函数")])]),e._v(" "),a("li",[a("p",[e._v("用template属性指定模板渲染的字符串")])])]),e._v(" "),a("h3",{attrs:{id:"如何选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选择","aria-hidden":"true"}},[e._v("#")]),e._v(" 如何选择")]),e._v(" "),a("p",[e._v("vue的package.json文件中的module属性指定了模块的入口文件为vue.runtime.esm.js，为什么呢，因为这个只包含了运行时，不包含编译器。相比全部包含的vue.esm.js文件而言，vue.runtime.esm.js体积小了将近三分之一，初始化运行速度相对来说会高一些。")]),e._v(" "),a("p",[e._v("我发现，在开发单页应用的时候，绝大多数情况下可以避免出现使用编译器的情况，所以，我只说下我遇到的情况。")]),e._v(" "),a("p",[e._v("通常，我们的单页应用的入口html，入口文件和顶级组件分别是index.html, main.js和App.js。代码如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\x3c!-- index.html --\x3e\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <title></title>\n  </head>\n  <body>\n    <div id=\"app\">\n    </div>\n    \x3c!-- built files will be auto injected --\x3e\n  </body>\n</html>\n\n\x3c!-- main.js --\x3e\nimport Vue from 'vue'\nimport App from './App'\n\nVue.config.productionTip = false\n\nnew Vue({\n  el: '#app',\n  template: '<App/>',\n  components: {App}\n})\n\n\x3c!-- App.vue --\x3e\n<template>\n  <div>\n    HelloWorld\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App'\n}\n<\/script>\n")])])]),a("p",[e._v("就像上面这种情况，初始化根实例的时候，用template指定了挂载元素，这就意味着，一定要用编译器。如果你的webpack.config.js里面没有设置vue的alias，并且，在main.js文件中，直接使用import Vue from 'vue'，你会发现，浏览器会报错:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.\n")])])]),a("p",[e._v("但是，如果你把")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import Vue from 'vue'\n")])])]),a("p",[e._v("改成")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import Vue from 'vue/dist/vue.esm.js'\n")])])]),a("p",[e._v("就会运行正常。\n不知道有多少项目都只是因为这个根实例导致不得不引入vue.esm.js。")]),e._v(" "),a("p",[e._v("那么，针对这个情况怎么解决呢？想必很多人都知道答案了。代码如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\x3c!-- index.html --\x3e\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <title></title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    \x3c!-- built files will be auto injected --\x3e\n  </body>\n</html>\n\n\x3c!-- main.js --\x3e\nimport Vue from 'vue'\nimport App from './App'\n\nVue.config.productionTip = false\n\nnew Vue({\n  el: '#app',\n  render(h) {\n    return h(App)\n  }\n})\n\n\x3c!-- App.vue --\x3e\n<template>\n  <div>\n    HelloWorld\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App'\n}\n<\/script>\n")])])]),a("p",[e._v("其实只改了一行代码，就是把main.js中的template替换成render函数。之前发现有的项目用render有的直接template，现在才知道是这么回事。")]),e._v(" "),a("h2",{attrs:{id:"二-esm和common什么关系，为什么除了runtime-esm和esm之外，还有vue-common-js和vue-js呢？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-esm和common什么关系，为什么除了runtime-esm和esm之外，还有vue-common-js和vue-js呢？","aria-hidden":"true"}},[e._v("#")]),e._v(" 二. esm和common什么关系，为什么除了runtime.esm和esm之外，还有vue.common.js和vue.js呢？")]),e._v(" "),a("h3",{attrs:{id:"_1-esm全称是esmodule，意思是遵循es6的import-export模块化规则。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-esm全称是esmodule，意思是遵循es6的import-export模块化规则。","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. esm全称是ESModule，意思是遵循es6的import export模块化规则。")]),e._v(" "),a("h3",{attrs:{id:"_2-common的意思是遵循common-js的exports模块化规则。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-common的意思是遵循common-js的exports模块化规则。","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. common的意思是遵循common.js的exports模块化规则。")]),e._v(" "),a("h3",{attrs:{id:"_3-如何选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何选择","aria-hidden":"true"}},[e._v("#")]),e._v(" 3. 如何选择?")]),e._v(" "),a("p",[e._v("我们知道common.js的模块化是输出一个exports对象，没法做到按需引入，一旦引入，就是用 require引入整个exports对象。但是ES6的import 可以选择引入哪些属性。")]),e._v(" "),a("p",[e._v("前者是运行时引入，后者是编译时引入（NodeJS打包）。由于编译时即可知道哪些是没有用到的，这样就可以达到tree shaking的目的（通过webpack配合达到）。")]),e._v(" "),a("p",[e._v("esm.js文件里面是符合ES6模块规则的es5的语法，是经过babel编译过的。为什么要是es5的语法呢？一般情况下业务代码在使用babel-loader的时候会exclude掉node_module目录，这是因为，node_module目录里面有大量的源代码，处理起来很浪费时间，所以干脆模块开发者帮你编译好，别人直接用你编译好的，而且能tree shaking的代码版本即可。")])])}],!1,null,null,null);t.default=s.exports}}]);