<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>__proto__ 是什么 | Sharemeans</title>
    <meta name="description" content="share everything we knowns">
    
    
    <link rel="preload" href="/vueBlog/assets/css/0.styles.2ee1bbf0.css" as="style"><link rel="preload" href="/vueBlog/assets/js/app.db9d678b.js" as="script"><link rel="preload" href="/vueBlog/assets/js/15.da36af82.js" as="script"><link rel="prefetch" href="/vueBlog/assets/js/10.e52248ed.js"><link rel="prefetch" href="/vueBlog/assets/js/11.a14a13fa.js"><link rel="prefetch" href="/vueBlog/assets/js/12.2d35b866.js"><link rel="prefetch" href="/vueBlog/assets/js/13.3772fa47.js"><link rel="prefetch" href="/vueBlog/assets/js/14.7e602616.js"><link rel="prefetch" href="/vueBlog/assets/js/16.ae416c7c.js"><link rel="prefetch" href="/vueBlog/assets/js/17.d141206b.js"><link rel="prefetch" href="/vueBlog/assets/js/18.ee496bc6.js"><link rel="prefetch" href="/vueBlog/assets/js/19.c6a50fec.js"><link rel="prefetch" href="/vueBlog/assets/js/2.3753830e.js"><link rel="prefetch" href="/vueBlog/assets/js/20.5a54938a.js"><link rel="prefetch" href="/vueBlog/assets/js/3.d7bc5234.js"><link rel="prefetch" href="/vueBlog/assets/js/4.4a1900a7.js"><link rel="prefetch" href="/vueBlog/assets/js/5.db1b67e1.js"><link rel="prefetch" href="/vueBlog/assets/js/6.1c44d2bf.js"><link rel="prefetch" href="/vueBlog/assets/js/7.e515983c.js"><link rel="prefetch" href="/vueBlog/assets/js/8.91265c5b.js"><link rel="prefetch" href="/vueBlog/assets/js/9.9f6d2172.js">
    <link rel="stylesheet" href="/vueBlog/assets/css/0.styles.2ee1bbf0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vueBlog/" class="home-link router-link-active"><!----> <span class="site-name">Sharemeans</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vueBlog/blogs/" class="nav-link">Blog</a></div><div class="nav-item"><a href="/vueBlog/vue/" class="nav-link">Vue</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vueBlog/blogs/" class="nav-link">Blog</a></div><div class="nav-item"><a href="/vueBlog/vue/" class="nav-link">Vue</a></div> <!----></nav>  <!----> </div> <div class="page"> <div class="content"><h3 id="proto-是什么"><a href="#proto-是什么" aria-hidden="true" class="header-anchor">#</a> __proto__ 是什么</h3> <p>__proto__是一个引用类型特有的属性，他的值指向原型。</p> <p>原型是什么？我的理解是，原型其实就是祖先。一个变量如果有这个属性，说明它继承于某个原型。</p> <h3 id="prototype-是什么"><a href="#prototype-是什么" aria-hidden="true" class="header-anchor">#</a> prototype 是什么</h3> <p>prototype是一个函数（普通函数，构造函数或class）的唯一标识。他默认包含__proto__和constructor</p> <p>可以用如下方式给这个函数添加其它可继承的属性和方法：</p> <div class="language- extra-class"><pre class="language-text"><code>SuperArray.prototype = {
    getValue: function() {
        console.log('this.value', this.value)
    },
    diff: function(comparisonArray) {
        const hash = new Set(comparisonArray);
        return this.filter(elem =&gt; !hash.has(elem));
    }
}
</code></pre></div><p>constructor指向函数本身，即：</p> <div class="language- extra-class"><pre class="language-text"><code>SuperArray.prototype.constructor === SuperArray
</code></pre></div><p>需要注意的是，prototype下的属性，引用类型是所有实例共用的，简单类型是不共用的。</p> <h3 id="new-操作符做了什么？"><a href="#new-操作符做了什么？" aria-hidden="true" class="header-anchor">#</a> new 操作符做了什么？</h3> <div class="language- extra-class"><pre class="language-text"><code>class SuperArray extends Array {
    constructor() {
        super()
        this.config = {
            name: 'Jack',
            age: '12'
        }
    }
    getValue() {
        console.log('this.config', this.config)
    }
    diff(comparisonArray) {
        const hash = new Set(comparisonArray);
        return this.filter(elem =&gt; !hash.has(elem));
    }
}
const sArray1 = new SuperArray()
console.log('sArray1', sArray1)

// 输入结果：
sArray1 -&gt; SuperArray:
config: {name: &quot;Jack&quot;, age: &quot;12&quot;}
length: 0
__proto__: Array
</code></pre></div><p>其实new 只做了4件事：</p> <ol><li>let obj = {}</li> <li>obj.__proto__ = SuperArray.prototype</li> <li>SuperArray.call(obj)</li> <li>返回obj</li></ol> <h3 id="extends-做了什么？"><a href="#extends-做了什么？" aria-hidden="true" class="header-anchor">#</a> extends 做了什么？</h3> <p>我们回看上面的类SuperArray继承于Array，输出SuperArray.prototype看下：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log('SuperArray.prototype', SuperArray.prototype)

// 输出结果：
SuperArray.prototype -&gt; Array:
constructor: class SuperArray
    arguments: (...)
    caller: (...)
    length: 0
    name: &quot;SuperArray&quot;
    prototype: Array {constructor: ƒ, getValue: ƒ, diff: ƒ}
    Symbol(Symbol.species): (...)
    __proto__: ƒ Array()
    [[FunctionLocation]]: index.html:47
    [[Scopes]]: Scopes[2]
diff: diff(comparisonArray) { const hash = new Set(comparisonArray); return this.filter(elem =&gt; {…}
getValue: ƒ getValue()
__proto__: Array(0)
</code></pre></div><p>extends做了以下事情：</p> <ol><li>初始化constructor</li> <li>设置prototype为父类的prototype（原型继承，不能直接赋值，否则无法实现继承关系）</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function extend(subClass, superClass) {
  var F = function() {};
  F.prototype = superClass.prototype;
  subClass.prototype = new F();

  subClass.superclass = superClass.prototype;
  if(superClass.prototype.constructor == Object.prototype.constructor) {
    superClass.prototype.constructor = superClass;
  }
}
</code></pre></div><ol start="3"><li>设置prototype的属性constructor为SuperArray。__proto__为Function.prototype（构造函数的原型是Function）。设置自定义属性和方法。</li></ol> <h5 id="proto-array-0-代表着什么？"><a href="#proto-array-0-代表着什么？" aria-hidden="true" class="header-anchor">#</a> <strong>proto</strong>: Array(0)代表着什么？</h5> <h3 id="extends的实现"><a href="#extends的实现" aria-hidden="true" class="header-anchor">#</a> extends的实现</h3> <div class="language- extra-class"><pre class="language-text"><code>function extend(subClass, superClass) {
  var F = function() {};
  F.prototype = superClass.prototype;
  subClass.prototype = new F();
  subClass.prototype.constructor = subClass
  subClass.prototype.sayName = function(){
    alert(this.name);
  };
  subClass.superclass = superClass.prototype;
  if(superClass.prototype.constructor == Object.prototype.constructor) {
    superClass.prototype.constructor = superClass;
  }
}
</code></pre></div><h3 id="instanceof到底做了什么事？"><a href="#instanceof到底做了什么事？" aria-hidden="true" class="header-anchor">#</a> instanceof到底做了什么事？</h3> <p>instanceof实际上是拿变量的__proto__.__proto__....和被对比的构造函数的prototype做===（全等）比较</p> <p>参考：
https://segmentfault.com/q/1010000012185778</p> <p>https://juejin.im/post/58f94c9bb123db411953691b#heading-5</p> <p>https://juejin.im/entry/58f62135a22b9d006c0cee45</p> <p>https://juejin.im/post/5b729c24f265da280f3ad010</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/vueBlog/assets/js/app.db9d678b.js" defer></script><script src="/vueBlog/assets/js/15.da36af82.js" defer></script>
  </body>
</html>
