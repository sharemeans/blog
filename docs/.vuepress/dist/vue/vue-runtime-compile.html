<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue.runtime &amp; vue.esm | Sharemeans</title>
    <meta name="description" content="share everything we knowns">
    
    
    <link rel="preload" href="/assets/css/0.styles.6d510c64.css" as="style"><link rel="preload" href="/assets/js/app.cd40470f.js" as="script"><link rel="preload" href="/assets/js/24.4d9bcc65.js" as="script"><link rel="prefetch" href="/assets/js/10.33c3fad3.js"><link rel="prefetch" href="/assets/js/11.2857d45c.js"><link rel="prefetch" href="/assets/js/12.b79a8b6a.js"><link rel="prefetch" href="/assets/js/13.bff61f36.js"><link rel="prefetch" href="/assets/js/14.aa053314.js"><link rel="prefetch" href="/assets/js/15.55600b79.js"><link rel="prefetch" href="/assets/js/16.a0f05db0.js"><link rel="prefetch" href="/assets/js/17.f2441ab9.js"><link rel="prefetch" href="/assets/js/18.cb3a6ef8.js"><link rel="prefetch" href="/assets/js/19.bbda91a4.js"><link rel="prefetch" href="/assets/js/2.931a971c.js"><link rel="prefetch" href="/assets/js/20.56fc7130.js"><link rel="prefetch" href="/assets/js/21.4015a440.js"><link rel="prefetch" href="/assets/js/22.48c2122f.js"><link rel="prefetch" href="/assets/js/23.9d1934fe.js"><link rel="prefetch" href="/assets/js/25.ded35db5.js"><link rel="prefetch" href="/assets/js/26.d00302b9.js"><link rel="prefetch" href="/assets/js/27.a81d98a4.js"><link rel="prefetch" href="/assets/js/3.5da879df.js"><link rel="prefetch" href="/assets/js/4.5057fa2f.js"><link rel="prefetch" href="/assets/js/5.5597b9cc.js"><link rel="prefetch" href="/assets/js/6.c5f3d2d5.js"><link rel="prefetch" href="/assets/js/7.a3c4ce89.js"><link rel="prefetch" href="/assets/js/8.e7c5623a.js"><link rel="prefetch" href="/assets/js/9.5f9952c2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6d510c64.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Sharemeans</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blogs/" class="nav-link">Blog</a></div><div class="nav-item"><a href="/vue/" class="nav-link router-link-active">Vue</a></div><div class="nav-item"><a href="/think/" class="nav-link">Think</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blogs/" class="nav-link">Blog</a></div><div class="nav-item"><a href="/vue/" class="nav-link router-link-active">Vue</a></div><div class="nav-item"><a href="/think/" class="nav-link">Think</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vue/mount-flow.html" class="sidebar-link">vue 的mount 过程</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue-runtime-vue-esm"><a href="#vue-runtime-vue-esm" aria-hidden="true" class="header-anchor">#</a> vue.runtime &amp; vue.esm</h1> <h2 id="一-esm是vue-的“运行时”和“编译器”的集合"><a href="#一-esm是vue-的“运行时”和“编译器”的集合" aria-hidden="true" class="header-anchor">#</a> 一. esm是vue 的“运行时”和“编译器”的集合</h2> <h3 id="运行时"><a href="#运行时" aria-hidden="true" class="header-anchor">#</a> 运行时</h3> <p>运行时是用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p> <h3 id="编译器"><a href="#编译器" aria-hidden="true" class="header-anchor">#</a> 编译器</h3> <p>用来将模板字符串编译成为 JavaScript 渲染函数的代码。</p> <p>在客户端编译模板包含以下情况：</p> <ol><li><p>el属性指定模版挂载的DOM，和该DOM包含的html，也就是说，既没有指定template，又没有render函数</p></li> <li><p>用template属性指定模板渲染的字符串</p></li></ol> <h3 id="如何选择"><a href="#如何选择" aria-hidden="true" class="header-anchor">#</a> 如何选择</h3> <p>vue的package.json文件中的module属性指定了模块的入口文件为vue.runtime.esm.js，为什么呢，因为这个只包含了运行时，不包含编译器。相比全部包含的vue.esm.js文件而言，vue.runtime.esm.js体积小了将近三分之一，初始化运行速度相对来说会高一些。</p> <p>我发现，在开发单页应用的时候，绝大多数情况下可以避免出现使用编译器的情况，所以，我只说下我遇到的情况。</p> <p>通常，我们的单页应用的入口html，入口文件和顶级组件分别是index.html, main.js和App.js。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
    &lt;/div&gt;
    &lt;!-- built files will be auto injected --&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;!-- main.js --&gt;
import Vue from 'vue'
import App from './App'

Vue.config.productionTip = false

new Vue({
  el: '#app',
  template: '&lt;App/&gt;',
  components: {App}
})

&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    HelloWorld
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;
</code></pre></div><p>就像上面这种情况，初始化根实例的时候，用template指定了挂载元素，这就意味着，一定要用编译器。如果你的webpack.config.js里面没有设置vue的alias，并且，在main.js文件中，直接使用import Vue from 'vue'，你会发现，浏览器会报错:</p> <div class="language- extra-class"><pre class="language-text"><code>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.
</code></pre></div><p>但是，如果你把</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue'
</code></pre></div><p>改成</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue/dist/vue.esm.js'
</code></pre></div><p>就会运行正常。
不知道有多少项目都只是因为这个根实例导致不得不引入vue.esm.js。</p> <p>那么，针对这个情况怎么解决呢？想必很多人都知道答案了。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;!-- built files will be auto injected --&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;!-- main.js --&gt;
import Vue from 'vue'
import App from './App'

Vue.config.productionTip = false

new Vue({
  el: '#app',
  render(h) {
    return h(App)
  }
})

&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    HelloWorld
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;
</code></pre></div><p>其实只改了一行代码，就是把main.js中的template替换成render函数。之前发现有的项目用render有的直接template，现在才知道是这么回事。</p> <h2 id="二-esm和common什么关系，为什么除了runtime-esm和esm之外，还有vue-common-js和vue-js呢？"><a href="#二-esm和common什么关系，为什么除了runtime-esm和esm之外，还有vue-common-js和vue-js呢？" aria-hidden="true" class="header-anchor">#</a> 二. esm和common什么关系，为什么除了runtime.esm和esm之外，还有vue.common.js和vue.js呢？</h2> <h3 id="_1-esm全称是esmodule，意思是遵循es6的import-export模块化规则。"><a href="#_1-esm全称是esmodule，意思是遵循es6的import-export模块化规则。" aria-hidden="true" class="header-anchor">#</a> 1. esm全称是ESModule，意思是遵循es6的import export模块化规则。</h3> <h3 id="_2-common的意思是遵循common-js的exports模块化规则。"><a href="#_2-common的意思是遵循common-js的exports模块化规则。" aria-hidden="true" class="header-anchor">#</a> 2. common的意思是遵循common.js的exports模块化规则。</h3> <h3 id="_3-如何选择"><a href="#_3-如何选择" aria-hidden="true" class="header-anchor">#</a> 3. 如何选择?</h3> <p>我们知道common.js的模块化是输出一个exports对象，没法做到按需引入，一旦引入，就是用 require引入整个exports对象。但是ES6的import 可以选择引入哪些属性。</p> <p>前者是运行时引入，后者是编译时引入（NodeJS打包）。由于编译时即可知道哪些是没有用到的，这样就可以达到tree shaking的目的（通过webpack配合达到）。</p> <p>esm.js文件里面是符合ES6模块规则的es5的语法，是经过babel编译过的。为什么要是es5的语法呢？一般情况下业务代码在使用babel-loader的时候会exclude掉node_module目录，这是因为，node_module目录里面有大量的源代码，处理起来很浪费时间，所以干脆模块开发者帮你编译好，别人直接用你编译好的，而且能tree shaking的代码版本即可。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.cd40470f.js" defer></script><script src="/assets/js/24.4d9bcc65.js" defer></script>
  </body>
</html>
